# .github/workflows/orchestrator.yml
#
# Processes tasks from the issue queue automatically.
# Triggers when a new issue is created with status:queued label.

name: Task Orchestrator

on:
  issues:
    types: [labeled]

permissions:
  issues: write
  contents: read

jobs:
  # Only run on queued tasks
  should-process:
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      task_type: ${{ steps.check.outputs.task_type }}
      project: ${{ steps.check.outputs.project }}
    steps:
      - name: Check if should process
        id: check
        uses: actions/github-script@v7
        with:
          script: |
            const labels = context.payload.issue.labels.map(l => l.name);
            const triggeringLabel = context.payload.label?.name;

            // Only process when status:queued is the triggering label
            // This prevents duplicate runs when multiple labels are added at once
            if (triggeringLabel !== 'status:queued') {
              core.setOutput('should_run', 'false');
              return;
            }

            // Don't re-process
            if (labels.includes('status:processing') ||
                labels.includes('status:ready') ||
                labels.includes('status:blocked')) {
              core.setOutput('should_run', 'false');
              return;
            }

            core.setOutput('should_run', 'true');
            
            // Determine type
            if (labels.includes('type:code')) {
              core.setOutput('task_type', 'code');
            } else if (labels.includes('type:writing')) {
              core.setOutput('task_type', 'writing');
            } else if (labels.includes('type:thinking')) {
              core.setOutput('task_type', 'thinking');
            } else {
              core.setOutput('task_type', 'auto');
            }
            
            // Determine project
            const projectLabel = labels.find(l => l.startsWith('project:'));
            core.setOutput('project', projectLabel ? projectLabel.replace('project:', '') : 'unknown');

  # Mark as processing
  start-processing:
    needs: should-process
    if: needs.should-process.outputs.should_run == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Update labels
        uses: actions/github-script@v7
        with:
          script: |
            // Remove queued, add processing
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              name: 'status:queued'
            }).catch(() => {});
            
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['status:processing']
            });

  # Route to appropriate processor
  process-code:
    needs: [should-process, start-processing]
    if: needs.should-process.outputs.task_type == 'code'
    runs-on: self-hosted
    steps:
      - name: Get task details
        id: task
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');
            core.setOutput('number', issue.number);
            return issue;

      - name: Determine target project
        id: project
        run: |
          PROJECT="${{ needs.should-process.outputs.project }}"
          case "$PROJECT" in
            offerlab)
              echo "dir=/home/runner/projects/offerlab" >> $GITHUB_OUTPUT
              echo "repo=bborn/offerlab" >> $GITHUB_OUTPUT
              echo "name=offerlab" >> $GITHUB_OUTPUT
              ;;
            influencekit)
              echo "dir=/home/runner/projects/influencekit" >> $GITHUB_OUTPUT
              echo "repo=bborn/influencekit" >> $GITHUB_OUTPUT
              echo "name=influencekit" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "dir=" >> $GITHUB_OUTPUT
              echo "repo=" >> $GITHUB_OUTPUT
              echo "name=unknown" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Prepare workspace
        if: steps.project.outputs.dir != ''
        id: workspace
        working-directory: ${{ steps.project.outputs.dir }}
        run: |
          # Ensure main is up to date
          git checkout main
          git pull origin main

          # Create task branch and worktree
          BRANCH="task-${{ steps.task.outputs.number }}"
          WORKTREE_DIR="/home/runner/worktrees/${{ steps.project.outputs.name }}-task-${{ steps.task.outputs.number }}"

          # Clean up any existing worktree for this task
          if [ -d "$WORKTREE_DIR" ]; then
            git worktree remove "$WORKTREE_DIR" --force 2>/dev/null || rm -rf "$WORKTREE_DIR"
          fi
          git worktree prune

          # Delete the branch if it exists (to start fresh from main)
          git branch -D "$BRANCH" 2>/dev/null || true

          # Create new worktree with task branch based on main
          git worktree add -b "$BRANCH" "$WORKTREE_DIR" main

          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "worktree_dir=$WORKTREE_DIR" >> $GITHUB_OUTPUT

      - name: Run Claude Code
        if: steps.project.outputs.dir != ''
        id: claude
        working-directory: ${{ steps.workspace.outputs.worktree_dir }}
        env:
          GH_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          PROMPT="You are working on: ${{ steps.project.outputs.name }}

          Task: ${{ steps.task.outputs.title }}

          ${{ steps.task.outputs.body }}

          IMPORTANT: If the task contains a Linear URL (linear.app/...), use your Linear MCP tools to fetch the full issue details FIRST. Get the title, description, acceptance criteria, and any comments to fully understand what needs to be done.

          Instructions:
          - Fetch Linear issue details if a Linear URL is present
          - Explore the codebase to understand the context
          - Implement the solution
          - Write tests if applicable
          - Commit your changes with clear messages
          - You have full access to all tools - use whatever you need

          When finished successfully, output these lines:
          TASK_COMPLETE
          PR_TITLE: <concise title describing what changed, e.g. 'Add dark mode toggle to settings page'>
          PR_SUMMARY: <2-4 bullet points summarizing the key changes you made>
          PR_TEST_PLAN: <how to test these changes, bullet points>

          If you need input from me: output NEEDS_INPUT: followed by your question"

          # Setup logging
          LOG_DIR="/home/runner/logs"
          mkdir -p "$LOG_DIR"
          LOG_FILE="$LOG_DIR/task-${{ github.event.issue.number }}-$(date +%Y%m%d-%H%M%S).txt"

          # Symlink for task watch
          ln -sf "$LOG_FILE" /tmp/claude_output.txt

          # Run Claude with full permissions (stream-json for full conversation log)
          claude -p "$PROMPT" \
            --dangerously-skip-permissions \
            --max-turns 50 \
            --output-format stream-json \
            --verbose \
            2>&1 | tee "$LOG_FILE" || true

          echo "log_file=$LOG_FILE" >> $GITHUB_OUTPUT

          # Extract the last assistant message for parsing
          FINAL_MSG=$(grep '"type":"assistant"' "$LOG_FILE" | tail -1 | jq -r '.message.content[]?.text // empty' 2>/dev/null || cat "$LOG_FILE")

          # Check result
          if echo "$FINAL_MSG" | grep -q "TASK_COMPLETE"; then
            echo "result=complete" >> $GITHUB_OUTPUT

            # Parse PR details from Claude's output
            PR_TITLE=$(echo "$FINAL_MSG" | grep -i "^PR_TITLE:" | sed 's/PR_TITLE:[[:space:]]*//' | head -1)
            PR_SUMMARY=$(echo "$FINAL_MSG" | sed -n '/^PR_SUMMARY:/,/^PR_TEST_PLAN:/p' | grep -v "^PR_TEST_PLAN:" | sed 's/PR_SUMMARY:[[:space:]]*//')
            PR_TEST_PLAN=$(echo "$FINAL_MSG" | sed -n '/^PR_TEST_PLAN:/,$p' | sed 's/PR_TEST_PLAN:[[:space:]]*//')

            # Use task title as fallback
            [ -z "$PR_TITLE" ] && PR_TITLE="${{ steps.task.outputs.title }}"
            [ -z "$PR_SUMMARY" ] && PR_SUMMARY="Implements: ${{ steps.task.outputs.title }}"
            [ -z "$PR_TEST_PLAN" ] && PR_TEST_PLAN="- Manual testing"

            # Output PR details (using heredoc for multiline)
            echo "pr_title<<EOF" >> $GITHUB_OUTPUT
            echo "$PR_TITLE" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "pr_summary<<EOF" >> $GITHUB_OUTPUT
            echo "$PR_SUMMARY" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

            echo "pr_test_plan<<EOF" >> $GITHUB_OUTPUT
            echo "$PR_TEST_PLAN" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT

          elif echo "$FINAL_MSG" | grep -q "NEEDS_INPUT"; then
            echo "result=needs_input" >> $GITHUB_OUTPUT
            echo "$FINAL_MSG" | grep "NEEDS_INPUT" | head -1 | sed 's/NEEDS_INPUT://' > /tmp/question.txt
          else
            echo "result=error" >> $GITHUB_OUTPUT
          fi

      - name: Push and create PR
        if: steps.claude.outputs.result == 'complete'
        id: pr
        working-directory: ${{ steps.workspace.outputs.worktree_dir }}
        env:
          GH_TOKEN: ${{ secrets.REPO_ACCESS_TOKEN }}
          PR_TITLE: ${{ steps.claude.outputs.pr_title }}
          PR_SUMMARY: ${{ steps.claude.outputs.pr_summary }}
          PR_TEST_PLAN: ${{ steps.claude.outputs.pr_test_plan }}
          TASK_URL: https://github.com/${{ github.repository }}/issues/${{ github.event.issue.number }}
        run: |
          # Push the branch
          git push -u origin "${{ steps.workspace.outputs.branch }}"

          # Build PR body
          printf '%s\n' "## Summary" "" "$PR_SUMMARY" "" "## Test Plan" "" "$PR_TEST_PLAN" "" "---" "" "ðŸ”— Task: $TASK_URL" "" "ðŸ¤– *Automated by [Claude Code](https://claude.com/claude-code)*" > /tmp/pr_body.md

          # Create PR with Claude-generated title and description
          PR_URL=$(gh pr create \
            --title "$PR_TITLE" \
            --body-file /tmp/pr_body.md \
            --head "${{ steps.workspace.outputs.branch }}")

          echo "url=$PR_URL" >> $GITHUB_OUTPUT

      - name: Cleanup worktree
        if: always() && steps.workspace.outputs.worktree_dir != ''
        working-directory: ${{ steps.project.outputs.dir }}
        run: |
          # Remove the worktree
          git worktree remove "${{ steps.workspace.outputs.worktree_dir }}" --force 2>/dev/null || rm -rf "${{ steps.workspace.outputs.worktree_dir }}"
          git worktree prune

      - name: Update issue - success
        if: steps.claude.outputs.result == 'complete'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          # Post success comment
          BODY="âœ… **Task completed!**

          PR created: ${{ steps.pr.outputs.url }}"

          jq -n --arg body "$BODY" '{"body": $body}' > /tmp/payload.json
          curl -s -X POST \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            -d @/tmp/payload.json \
            "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments"

      - name: Update issue - needs input
        if: steps.claude.outputs.result == 'needs_input'
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          QUESTION=$(cat /tmp/question.txt 2>/dev/null || echo "Claude needs clarification")

          BODY="â“ **@bborn - Input needed**

          $QUESTION"

          jq -n --arg body "$BODY" '{"body": $body}' > /tmp/payload.json
          curl -s -X POST \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            -d @/tmp/payload.json \
            "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments"

      - name: Update issue - error
        if: steps.claude.outputs.result == 'error' || steps.project.outputs.dir == ''
        env:
          GH_TOKEN: ${{ github.token }}
          LOG_FILE: ${{ steps.claude.outputs.log_file }}
        run: |
          if [ -z "${{ steps.project.outputs.dir }}" ]; then
            MSG="Could not determine target project. Add a project label (e.g. project:offerlab)"
            DETAILS=""
          else
            MSG="Task did not complete successfully."
            DETAILS=""

            # Extract last Claude messages from log
            if [ -f "$LOG_FILE" ]; then
              LAST_MSGS=$(grep '"type":"assistant"' "$LOG_FILE" | tail -5 | jq -r '.message.content[]? | if .type == "text" then .text elif .type == "tool_use" then "ðŸ”§ " + .name else empty end' 2>/dev/null | tail -20)
              ERRORS=$(grep -i '"error"\|"Error"\|failed\|exception' "$LOG_FILE" | tail -3 | head -c 300 || true)

              echo "**Last activity:**" > /tmp/details.txt
              echo '```' >> /tmp/details.txt
              echo "${LAST_MSGS:-No messages found}" >> /tmp/details.txt
              echo '```' >> /tmp/details.txt

              if [ -n "$ERRORS" ]; then
                echo "" >> /tmp/details.txt
                echo "**Errors detected:**" >> /tmp/details.txt
                echo '```' >> /tmp/details.txt
                echo "$ERRORS" >> /tmp/details.txt
                echo '```' >> /tmp/details.txt
              fi
              DETAILS=$(cat /tmp/details.txt)
            fi
          fi

          printf '%s\n\n%s\n\n%s\n' "âš ï¸ **@bborn - Error**" "$MSG" "$DETAILS" > /tmp/error_body.txt
          jq -n --rawfile body /tmp/error_body.txt '{"body": $body}' > /tmp/payload.json
          curl -s -X POST \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            -d @/tmp/payload.json \
            "https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.issue.number }}/comments"

      - name: Update labels
        uses: actions/github-script@v7
        with:
          script: |
            const result = '${{ steps.claude.outputs.result }}';
            const newLabel = result === 'complete' ? 'status:ready' : 'status:blocked';

            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              name: 'status:processing'
            }).catch(() => {});

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: [newLabel]
            });

  # Writing tasks - use Claude Code
  process-writing:
    needs: [should-process, start-processing]
    if: needs.should-process.outputs.task_type == 'writing'
    runs-on: self-hosted
    steps:
      - name: Get task details
        id: task
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');
            return issue;

      - name: Generate content with Claude Code
        id: generate
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          PROMPT="You are a skilled writer. Please complete this task:

          Task: ${{ steps.task.outputs.title }}

          Details: ${{ steps.task.outputs.body }}

          Write the requested content. Be professional, clear, and match the appropriate tone.
          Output only the final content, no meta-commentary."

          # Setup logging
          LOG_DIR="/home/runner/logs"
          mkdir -p "$LOG_DIR"
          LOG_FILE="$LOG_DIR/task-${{ github.event.issue.number }}-$(date +%Y%m%d-%H%M%S).txt"
          ln -sf "$LOG_FILE" /tmp/claude_output.txt

          # Run Claude Code (stream-json for full conversation log)
          claude -p "$PROMPT" --max-turns 3 --output-format stream-json --verbose 2>&1 | tee "$LOG_FILE" || true

          # Extract text content from stream-json for the comment
          grep '"type":"assistant"' "$LOG_FILE" | jq -r '.message.content[]?.text // empty' > /tmp/content.txt 2>/dev/null || cp "$LOG_FILE" /tmp/content.txt

          # Build comment body
          {
            echo "âœ… **Content generated:**"
            echo ""
            echo "---"
            echo ""
            cat /tmp/content.txt
            echo ""
            echo "---"
            echo ""
            echo "*Copy the above content to use it.*"
          } > /tmp/body.txt

          # Post comment using curl
          jq -n --rawfile body /tmp/body.txt '{"body": $body}' > /tmp/payload.json
          curl -s -X POST \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            -d @/tmp/payload.json \
            "https://api.github.com/repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/comments"

      - name: Update labels
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              name: 'status:processing'
            }).catch(() => {});

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['status:ready']
            });

  # Thinking tasks - analysis with Claude Code
  process-thinking:
    needs: [should-process, start-processing]
    if: needs.should-process.outputs.task_type == 'thinking'
    runs-on: self-hosted
    steps:
      - name: Get task details
        id: task
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');
            return issue;

      - name: Analyze with Claude Code
        id: analyze
        env:
          GH_TOKEN: ${{ github.token }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          PROMPT="You are a strategic advisor. Analyze this thoroughly:

          Question: ${{ steps.task.outputs.title }}

          Context: ${{ steps.task.outputs.body }}

          Provide:
          1. Clear analysis of the question/problem
          2. Key considerations and tradeoffs
          3. Recommended approach
          4. Concrete next steps

          Think deeply but be actionable."

          # Setup logging
          LOG_DIR="/home/runner/logs"
          mkdir -p "$LOG_DIR"
          LOG_FILE="$LOG_DIR/task-${{ github.event.issue.number }}-$(date +%Y%m%d-%H%M%S).txt"
          ln -sf "$LOG_FILE" /tmp/claude_output.txt

          # Run Claude Code (stream-json for full conversation log)
          claude -p "$PROMPT" --max-turns 3 --output-format stream-json --verbose 2>&1 | tee "$LOG_FILE" || true

          # Extract text content from stream-json for the comment
          grep '"type":"assistant"' "$LOG_FILE" | jq -r '.message.content[]?.text // empty' > /tmp/content.txt 2>/dev/null || cp "$LOG_FILE" /tmp/content.txt

          # Build comment body
          {
            echo "âœ… **Analysis complete:**"
            echo ""
            cat /tmp/content.txt
          } > /tmp/body.txt

          # Post comment using curl
          jq -n --rawfile body /tmp/body.txt '{"body": $body}' > /tmp/payload.json
          curl -s -X POST \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github.v3+json" \
            -d @/tmp/payload.json \
            "https://api.github.com/repos/${{ github.repository }}/issues/${ISSUE_NUMBER}/comments"

      - name: Update labels
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              name: 'status:processing'
            }).catch(() => {});

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['status:ready']
            });

  # Triage tasks without a type - Claude Code reviews, refines, and classifies
  triage:
    needs: [should-process, start-processing]
    if: needs.should-process.outputs.task_type == 'auto'
    runs-on: self-hosted
    steps:
      - name: Get task details
        id: task
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const labels = issue.labels.map(l => l.name).join(', ');
            core.setOutput('title', issue.title);
            core.setOutput('body', issue.body || '');
            core.setOutput('labels', labels);
            return issue;

      - name: Triage with Claude Code
        id: triage
        run: |
          PROMPT="You are a task triage assistant. Review this task and provide structured output.

          Task Title: ${{ steps.task.outputs.title }}
          Task Body: ${{ steps.task.outputs.body }}
          Existing Labels: ${{ steps.task.outputs.labels }}

          IMPORTANT: If the title or body contains a Linear URL (linear.app/...), use your Linear MCP tools to fetch the full issue details FIRST. Use the issue ID from the URL (e.g., OL-2647) to get the title, description, and any other relevant context.

          After gathering all context, respond in this EXACT format (each field on its own line):

          REFINED_TITLE: <A clearer, more actionable title based on the actual issue>
          REFINED_DESCRIPTION: <Full description with context from Linear if available>
          TYPE: <code|writing|thinking>
          PROJECT: <offerlab|influencekit|personal|unknown>
          CLARITY: <clear|needs_info>
          REASONING: <Brief 1-2 sentence explanation of your classification>

          Guidelines:
          - TYPE must be exactly one of: code, writing, thinking
          - code = software dev, bugs, features, refactoring
          - writing = emails, docs, blog posts, content creation
          - thinking = analysis, research, strategy, planning
          - PROJECT: infer from context if not labeled, use 'unknown' if unclear
          - CLARITY: 'clear' if you have enough info to act (including from Linear), 'needs_info' only if truly vague"

          # Setup logging
          LOG_DIR="/home/runner/logs"
          mkdir -p "$LOG_DIR"
          LOG_FILE="$LOG_DIR/triage-${{ github.event.issue.number }}-$(date +%Y%m%d-%H%M%S).txt"
          ln -sf "$LOG_FILE" /tmp/claude_output.txt

          # Run Claude Code (stream-json for full conversation log)
          claude -p "$PROMPT" --max-turns 10 --output-format stream-json --verbose 2>&1 | tee "$LOG_FILE" || true

          # Extract text content from stream-json
          CONTENT=$(grep '"type":"assistant"' "$LOG_FILE" | tail -1 | jq -r '.message.content[]?.text // empty' 2>/dev/null || cat "$LOG_FILE")

          # Debug: show response
          echo "=== Claude Response ==="
          echo "$CONTENT"
          echo "======================="

          # Parse structured response
          TYPE=$(echo "$CONTENT" | grep -i "^TYPE:" | sed 's/TYPE:[[:space:]]*//' | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')
          PROJECT=$(echo "$CONTENT" | grep -i "^PROJECT:" | sed 's/PROJECT:[[:space:]]*//' | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')
          CLARITY=$(echo "$CONTENT" | grep -i "^CLARITY:" | sed 's/CLARITY:[[:space:]]*//' | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')
          REFINED_TITLE=$(echo "$CONTENT" | grep -i "^REFINED_TITLE:" | sed 's/REFINED_TITLE:[[:space:]]*//')
          REASONING=$(echo "$CONTENT" | grep -i "^REASONING:" | sed 's/REASONING:[[:space:]]*//')

          # Extract refined description (may be multiline, so handle differently)
          REFINED_DESC=$(echo "$CONTENT" | sed -n '/^REFINED_DESCRIPTION:/,/^TYPE:/p' | head -n -1 | sed 's/REFINED_DESCRIPTION:[[:space:]]*//')

          # Defaults
          [[ -z "$TYPE" || ! "$TYPE" =~ ^(code|writing|thinking)$ ]] && TYPE="thinking"
          [[ -z "$CLARITY" ]] && CLARITY="clear"

          # Debug parsed values
          echo "=== Parsed Values ==="
          echo "TYPE: $TYPE"
          echo "PROJECT: $PROJECT"
          echo "CLARITY: $CLARITY"
          echo "REASONING: $REASONING"
          echo "===================="

          echo "type=$TYPE" >> $GITHUB_OUTPUT
          echo "project=$PROJECT" >> $GITHUB_OUTPUT
          echo "clarity=$CLARITY" >> $GITHUB_OUTPUT
          echo "reasoning=$REASONING" >> $GITHUB_OUTPUT

          # Handle multiline for refined title/desc
          echo "refined_title<<EOF" >> $GITHUB_OUTPUT
          echo "$REFINED_TITLE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          echo "refined_desc<<EOF" >> $GITHUB_OUTPUT
          echo "$REFINED_DESC" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          # Full response for comment
          echo "full_response<<EOF" >> $GITHUB_OUTPUT
          echo "$CONTENT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Post triage comment
        uses: actions/github-script@v7
        with:
          script: |
            const type = '${{ steps.triage.outputs.type }}';
            const project = '${{ steps.triage.outputs.project }}';
            const clarity = '${{ steps.triage.outputs.clarity }}';
            const reasoning = `${{ steps.triage.outputs.reasoning }}`;
            const refinedTitle = `${{ steps.triage.outputs.refined_title }}`;
            const refinedDesc = `${{ steps.triage.outputs.refined_desc }}`;

            let comment = `ðŸ¤– **Task Triaged**\n\n`;
            comment += `**Type:** \`${type}\`\n`;
            comment += `**Project:** \`${project}\`\n`;
            comment += `**Clarity:** ${clarity === 'clear' ? 'âœ… Clear' : 'âš ï¸ Needs more info'}\n\n`;

            if (refinedTitle && refinedTitle !== 'KEEP') {
              comment += `**Suggested Title:**\n> ${refinedTitle}\n\n`;
            }

            if (refinedDesc && refinedDesc !== 'KEEP') {
              comment += `**Suggested Description:**\n${refinedDesc}\n\n`;
            }

            comment += `**Reasoning:** ${reasoning}\n\n`;

            if (clarity === 'clear') {
              comment += `---\n*Proceeding to ${type} agent...*`;
            } else {
              comment += `---\n*â¸ï¸ Marked as blocked - please add more details, then use \`task requeue ${context.issue.number}\`*`;
            }

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });

      - name: Handle unclear tasks
        if: steps.triage.outputs.clarity == 'needs_info'
        uses: actions/github-script@v7
        with:
          script: |
            // Mark as blocked if task needs clarification
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              name: 'status:processing'
            }).catch(() => {});

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['status:blocked']
            });

      - name: Add labels and re-queue
        if: steps.triage.outputs.clarity != 'needs_info'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REPO_ACCESS_TOKEN }}
          script: |
            const type = '${{ steps.triage.outputs.type }}';
            const project = '${{ steps.triage.outputs.project }}';
            const existingProject = '${{ needs.should-process.outputs.project }}';

            const typeLabel = `type:${type}`;
            const labelsToAdd = [typeLabel];

            // Add project label if we determined one and there isn't one already
            if (project && project !== 'unknown' && existingProject === 'unknown') {
              labelsToAdd.push(`project:${project}`);
            }

            // IMPORTANT: Remove processing FIRST, before adding status:queued
            // Otherwise, when status:queued triggers the workflow, it will see
            // status:processing and bail out
            await github.rest.issues.removeLabel({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              name: 'status:processing'
            }).catch(() => {});

            // Add the type/project labels first
            if (labelsToAdd.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: labelsToAdd
              });
            }

            // Now add status:queued - this re-triggers the workflow
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['status:queued']
            });
