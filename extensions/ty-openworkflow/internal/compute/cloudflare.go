package compute

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

// CloudflareAdapter implements compute.Adapter for Cloudflare Workers.
type CloudflareAdapter struct {
	accountID  string
	apiToken   string
	namespace  string // D1 database namespace for state
	webhookURL string
	client     *http.Client
	baseURL    string
}

// CloudflareConfig holds configuration for the Cloudflare adapter.
type CloudflareConfig struct {
	AccountID string `yaml:"account_id"`
	APIToken  string `yaml:"api_token"`
	Namespace string `yaml:"namespace"` // KV namespace for workflow state
}

// NewCloudflareAdapter creates a new Cloudflare Workers adapter.
func NewCloudflareAdapter(cfg CloudflareConfig) *CloudflareAdapter {
	return &CloudflareAdapter{
		accountID: cfg.AccountID,
		apiToken:  cfg.APIToken,
		namespace: cfg.Namespace,
		client:    &http.Client{Timeout: 30 * time.Second},
		baseURL:   "https://api.cloudflare.com/client/v4",
	}
}

func (c *CloudflareAdapter) Name() string {
	return "cloudflare"
}

func (c *CloudflareAdapter) IsAvailable() bool {
	return c.accountID != "" && c.apiToken != ""
}

func (c *CloudflareAdapter) SetWebhook(url string) {
	c.webhookURL = url
}

// Deploy creates or updates a Cloudflare Worker with the workflow code.
func (c *CloudflareAdapter) Deploy(ctx context.Context, workflow *WorkflowDefinition) error {
	// Wrap the workflow code in an OpenWorkflow-compatible worker
	workerCode := c.generateWorkerCode(workflow)

	url := fmt.Sprintf("%s/accounts/%s/workers/scripts/ow-%s", c.baseURL, c.accountID, workflow.ID)

	// Create multipart form with worker script
	body := bytes.NewBufferString(workerCode)

	req, err := http.NewRequestWithContext(ctx, "PUT", url, body)
	if err != nil {
		return fmt.Errorf("create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+c.apiToken)
	req.Header.Set("Content-Type", "application/javascript")

	resp, err := c.client.Do(req)
	if err != nil {
		return fmt.Errorf("deploy worker: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		respBody, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("deploy failed (%d): %s", resp.StatusCode, string(respBody))
	}

	return nil
}

// generateWorkerCode wraps workflow code in a Cloudflare Worker with OpenWorkflow semantics.
func (c *CloudflareAdapter) generateWorkerCode(workflow *WorkflowDefinition) string {
	return fmt.Sprintf(`
// OpenWorkflow Worker: %s v%s
// Generated by ty-openworkflow

const WORKFLOW_ID = "%s";
const WEBHOOK_URL = "%s";

// Step execution with memoization
async function step(name, fn, env) {
  const stepKey = WORKFLOW_ID + ":" + env.RUN_ID + ":" + name;

  // Check KV for cached result
  const cached = await env.WORKFLOW_STATE.get(stepKey, { type: "json" });
  if (cached && cached.status === "completed") {
    return cached.output;
  }

  // Execute step
  const startedAt = new Date().toISOString();
  try {
    const output = await fn();
    await env.WORKFLOW_STATE.put(stepKey, JSON.stringify({
      status: "completed",
      output,
      startedAt,
      completedAt: new Date().toISOString()
    }));
    return output;
  } catch (error) {
    await env.WORKFLOW_STATE.put(stepKey, JSON.stringify({
      status: "failed",
      error: error.message,
      startedAt,
      completedAt: new Date().toISOString()
    }));
    throw error;
  }
}

// Sleep with durable scheduling
async function sleep(name, durationMs, env) {
  const stepKey = WORKFLOW_ID + ":" + env.RUN_ID + ":" + name + ":sleep";

  const cached = await env.WORKFLOW_STATE.get(stepKey, { type: "json" });
  if (cached && cached.status === "completed") {
    return;
  }

  if (cached && cached.status === "sleeping") {
    const wakeAt = new Date(cached.wakeAt);
    if (new Date() >= wakeAt) {
      await env.WORKFLOW_STATE.put(stepKey, JSON.stringify({
        status: "completed",
        completedAt: new Date().toISOString()
      }));
      return;
    }
    // Still sleeping - schedule continuation
    throw new Error("SLEEPING:" + cached.wakeAt);
  }

  // Start sleeping
  const wakeAt = new Date(Date.now() + durationMs).toISOString();
  await env.WORKFLOW_STATE.put(stepKey, JSON.stringify({
    status: "sleeping",
    wakeAt,
    startedAt: new Date().toISOString()
  }));
  throw new Error("SLEEPING:" + wakeAt);
}

// User workflow code
%s

// Worker entry point
export default {
  async fetch(request, env) {
    const url = new URL(request.url);

    if (request.method === "POST" && url.pathname === "/start") {
      const input = await request.json();
      const runID = crypto.randomUUID();

      // Store run state
      await env.WORKFLOW_STATE.put(WORKFLOW_ID + ":" + runID + ":meta", JSON.stringify({
        id: runID,
        workflowId: WORKFLOW_ID,
        status: "running",
        input,
        startedAt: new Date().toISOString()
      }));

      // Execute workflow
      env.RUN_ID = runID;
      try {
        const output = await workflow(input, { step: (n, f) => step(n, f, env), sleep: (n, d) => sleep(n, d, env) });

        // Mark completed
        await env.WORKFLOW_STATE.put(WORKFLOW_ID + ":" + runID + ":meta", JSON.stringify({
          id: runID,
          workflowId: WORKFLOW_ID,
          status: "completed",
          input,
          output,
          startedAt: new Date().toISOString(),
          completedAt: new Date().toISOString()
        }));

        // Call webhook
        if (WEBHOOK_URL) {
          await fetch(WEBHOOK_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ runId: runID, status: "completed", output })
          });
        }

        return Response.json({ runId: runID, status: "completed", output });
      } catch (error) {
        if (error.message.startsWith("SLEEPING:")) {
          const wakeAt = error.message.split(":")[1];
          return Response.json({ runId: runID, status: "sleeping", wakeAt });
        }

        // Mark failed
        await env.WORKFLOW_STATE.put(WORKFLOW_ID + ":" + runID + ":meta", JSON.stringify({
          id: runID,
          workflowId: WORKFLOW_ID,
          status: "failed",
          input,
          error: error.message,
          startedAt: new Date().toISOString(),
          completedAt: new Date().toISOString()
        }));

        if (WEBHOOK_URL) {
          await fetch(WEBHOOK_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ runId: runID, status: "failed", error: error.message })
          });
        }

        return Response.json({ runId: runID, status: "failed", error: error.message }, { status: 500 });
      }
    }

    if (request.method === "GET" && url.pathname.startsWith("/status/")) {
      const runID = url.pathname.split("/")[2];
      const meta = await env.WORKFLOW_STATE.get(WORKFLOW_ID + ":" + runID + ":meta", { type: "json" });
      if (!meta) {
        return Response.json({ error: "not found" }, { status: 404 });
      }
      return Response.json(meta);
    }

    return Response.json({ workflow: WORKFLOW_ID, version: "%s" });
  }
};
`, workflow.Name, workflow.Version, workflow.ID, c.webhookURL, workflow.Code, workflow.Version)
}

// Start initiates a new workflow run on Cloudflare Workers.
func (c *CloudflareAdapter) Start(ctx context.Context, workflowID string, input map[string]any) (*WorkflowRun, error) {
	url := fmt.Sprintf("https://ow-%s.%s.workers.dev/start", workflowID, c.accountID)

	body, err := json.Marshal(input)
	if err != nil {
		return nil, fmt.Errorf("marshal input: %w", err)
	}

	req, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	if err != nil {
		return nil, fmt.Errorf("create request: %w", err)
	}
	req.Header.Set("Content-Type", "application/json")

	resp, err := c.client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("start workflow: %w", err)
	}
	defer resp.Body.Close()

	var result struct {
		RunID  string         `json:"runId"`
		Status string         `json:"status"`
		Output map[string]any `json:"output,omitempty"`
		Error  string         `json:"error,omitempty"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("decode response: %w", err)
	}

	run := &WorkflowRun{
		ID:         result.RunID,
		WorkflowID: workflowID,
		Status:     RunStatus(result.Status),
		Input:      input,
		Output:     result.Output,
		Error:      result.Error,
		StartedAt:  time.Now(),
	}

	return run, nil
}

// Status retrieves the current status of a workflow run.
func (c *CloudflareAdapter) Status(ctx context.Context, runID string) (*WorkflowRun, error) {
	// We need to know the workflow ID to query - store it in local state
	// For now, assume workflow ID is embedded or use a registry
	return nil, fmt.Errorf("status check requires workflow ID lookup - use ListRuns instead")
}

// Cancel attempts to cancel a running workflow.
func (c *CloudflareAdapter) Cancel(ctx context.Context, runID string) error {
	// Cloudflare Workers don't have native cancellation
	// Mark as cancelled in KV state
	return fmt.Errorf("cancel not yet implemented for Cloudflare Workers")
}

// Logs retrieves execution logs for a workflow run.
func (c *CloudflareAdapter) Logs(ctx context.Context, runID string) ([]string, error) {
	// Use Cloudflare Logpush or tail workers for logs
	return nil, fmt.Errorf("logs retrieval not yet implemented")
}

// Cleanup removes completed workflow resources.
func (c *CloudflareAdapter) Cleanup(ctx context.Context, runID string) error {
	// Delete KV keys for this run
	return nil
}

// ListRuns returns recent workflow runs.
func (c *CloudflareAdapter) ListRuns(ctx context.Context, workflowID string, limit int) ([]*WorkflowRun, error) {
	// Query KV namespace for runs
	return nil, fmt.Errorf("list runs not yet implemented")
}
