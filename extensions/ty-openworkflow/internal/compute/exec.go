package compute

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sync"
	"time"
)

// ExecAdapter implements compute.Adapter for local process execution.
// Useful for development and testing, or for self-hosted deployments.
type ExecAdapter struct {
	workDir    string
	webhookURL string
	runs       map[string]*WorkflowRun
	processes  map[string]*exec.Cmd
	mu         sync.RWMutex
}

// ExecConfig holds configuration for the exec adapter.
type ExecConfig struct {
	WorkDir string `yaml:"work_dir"`
}

// NewExecAdapter creates a new local exec adapter.
func NewExecAdapter(cfg ExecConfig) *ExecAdapter {
	workDir := cfg.WorkDir
	if workDir == "" {
		workDir = filepath.Join(os.TempDir(), "ty-openworkflow")
	}
	os.MkdirAll(workDir, 0755)

	return &ExecAdapter{
		workDir:   workDir,
		runs:      make(map[string]*WorkflowRun),
		processes: make(map[string]*exec.Cmd),
	}
}

func (e *ExecAdapter) Name() string {
	return "exec"
}

func (e *ExecAdapter) IsAvailable() bool {
	return true // Local exec is always available
}

func (e *ExecAdapter) SetWebhook(url string) {
	e.webhookURL = url
}

// Deploy stores the workflow definition locally for execution.
func (e *ExecAdapter) Deploy(ctx context.Context, workflow *WorkflowDefinition) error {
	// Create workflow directory
	workflowDir := filepath.Join(e.workDir, "workflows", workflow.ID)
	if err := os.MkdirAll(workflowDir, 0755); err != nil {
		return fmt.Errorf("create workflow dir: %w", err)
	}

	// Write workflow code
	var filename string
	switch workflow.Runtime {
	case "node", "javascript":
		filename = "workflow.js"
	case "python":
		filename = "workflow.py"
	case "go":
		filename = "workflow.go"
	default:
		filename = "workflow.js"
	}

	codePath := filepath.Join(workflowDir, filename)
	if err := os.WriteFile(codePath, []byte(e.wrapWorkflowCode(workflow)), 0644); err != nil {
		return fmt.Errorf("write workflow code: %w", err)
	}

	// Write metadata
	metaPath := filepath.Join(workflowDir, "workflow.json")
	meta, _ := json.MarshalIndent(workflow, "", "  ")
	if err := os.WriteFile(metaPath, meta, 0644); err != nil {
		return fmt.Errorf("write metadata: %w", err)
	}

	return nil
}

// wrapWorkflowCode adds OpenWorkflow runtime support to the user's code.
func (e *ExecAdapter) wrapWorkflowCode(workflow *WorkflowDefinition) string {
	switch workflow.Runtime {
	case "node", "javascript":
		return e.wrapNodeWorkflow(workflow)
	case "python":
		return e.wrapPythonWorkflow(workflow)
	default:
		return e.wrapNodeWorkflow(workflow)
	}
}

func (e *ExecAdapter) wrapNodeWorkflow(workflow *WorkflowDefinition) string {
	return fmt.Sprintf(`#!/usr/bin/env node
// OpenWorkflow Runner: %s v%s
// Generated by ty-openworkflow

const fs = require('fs');
const path = require('path');

const WORKFLOW_ID = "%s";
const RUN_ID = process.env.RUN_ID;
const STATE_DIR = process.env.STATE_DIR || '.';
const WEBHOOK_URL = process.env.WEBHOOK_URL || '';

// State management
function getStateFile() {
  return path.join(STATE_DIR, RUN_ID + '.json');
}

function loadState() {
  try {
    return JSON.parse(fs.readFileSync(getStateFile(), 'utf8'));
  } catch {
    return { steps: {} };
  }
}

function saveState(state) {
  fs.writeFileSync(getStateFile(), JSON.stringify(state, null, 2));
}

// Step execution with memoization (deterministic replay)
async function step(name, fn) {
  const state = loadState();

  // Check for cached result
  if (state.steps[name] && state.steps[name].status === 'completed') {
    return state.steps[name].output;
  }

  // Execute step
  const startedAt = new Date().toISOString();
  try {
    const output = await fn();
    state.steps[name] = {
      status: 'completed',
      output,
      startedAt,
      completedAt: new Date().toISOString()
    };
    saveState(state);
    return output;
  } catch (error) {
    state.steps[name] = {
      status: 'failed',
      error: error.message,
      startedAt,
      completedAt: new Date().toISOString()
    };
    saveState(state);
    throw error;
  }
}

// Durable sleep
async function sleep(name, durationMs) {
  const state = loadState();
  const sleepKey = name + ':sleep';

  if (state.steps[sleepKey] && state.steps[sleepKey].status === 'completed') {
    return;
  }

  if (state.steps[sleepKey] && state.steps[sleepKey].status === 'sleeping') {
    const wakeAt = new Date(state.steps[sleepKey].wakeAt);
    if (new Date() >= wakeAt) {
      state.steps[sleepKey].status = 'completed';
      state.steps[sleepKey].completedAt = new Date().toISOString();
      saveState(state);
      return;
    }
    // Still sleeping
    const remaining = wakeAt - new Date();
    await new Promise(resolve => setTimeout(resolve, remaining));
    state.steps[sleepKey].status = 'completed';
    state.steps[sleepKey].completedAt = new Date().toISOString();
    saveState(state);
    return;
  }

  // Start sleeping
  const wakeAt = new Date(Date.now() + durationMs);
  state.steps[sleepKey] = {
    status: 'sleeping',
    wakeAt: wakeAt.toISOString(),
    startedAt: new Date().toISOString()
  };
  saveState(state);

  await new Promise(resolve => setTimeout(resolve, durationMs));

  state.steps[sleepKey].status = 'completed';
  state.steps[sleepKey].completedAt = new Date().toISOString();
  saveState(state);
}

// User workflow code
%s

// Main execution
async function main() {
  const input = JSON.parse(process.env.INPUT || '{}');

  try {
    const output = await workflow(input, { step, sleep });

    // Report completion
    console.log(JSON.stringify({ status: 'completed', output }));

    if (WEBHOOK_URL) {
      const https = require('https');
      const http = require('http');
      const url = new URL(WEBHOOK_URL);
      const client = url.protocol === 'https:' ? https : http;
      const req = client.request(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      req.write(JSON.stringify({ runId: RUN_ID, status: 'completed', output }));
      req.end();
    }

    process.exit(0);
  } catch (error) {
    console.error(JSON.stringify({ status: 'failed', error: error.message }));

    if (WEBHOOK_URL) {
      const https = require('https');
      const http = require('http');
      const url = new URL(WEBHOOK_URL);
      const client = url.protocol === 'https:' ? https : http;
      const req = client.request(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' }
      });
      req.write(JSON.stringify({ runId: RUN_ID, status: 'failed', error: error.message }));
      req.end();
    }

    process.exit(1);
  }
}

main();
`, workflow.Name, workflow.Version, workflow.ID, workflow.Code)
}

func (e *ExecAdapter) wrapPythonWorkflow(workflow *WorkflowDefinition) string {
	return fmt.Sprintf(`#!/usr/bin/env python3
# OpenWorkflow Runner: %s v%s
# Generated by ty-openworkflow

import os
import json
import time
import urllib.request
from datetime import datetime
from pathlib import Path

WORKFLOW_ID = "%s"
RUN_ID = os.environ.get("RUN_ID", "")
STATE_DIR = Path(os.environ.get("STATE_DIR", "."))
WEBHOOK_URL = os.environ.get("WEBHOOK_URL", "")

def get_state_file():
    return STATE_DIR / f"{RUN_ID}.json"

def load_state():
    try:
        with open(get_state_file()) as f:
            return json.load(f)
    except:
        return {"steps": {}}

def save_state(state):
    with open(get_state_file(), "w") as f:
        json.dump(state, f, indent=2)

def step(name, fn):
    """Execute a step with memoization (deterministic replay)."""
    state = load_state()

    # Check for cached result
    if name in state["steps"] and state["steps"][name].get("status") == "completed":
        return state["steps"][name]["output"]

    # Execute step
    started_at = datetime.now().isoformat()
    try:
        output = fn()
        state["steps"][name] = {
            "status": "completed",
            "output": output,
            "startedAt": started_at,
            "completedAt": datetime.now().isoformat()
        }
        save_state(state)
        return output
    except Exception as e:
        state["steps"][name] = {
            "status": "failed",
            "error": str(e),
            "startedAt": started_at,
            "completedAt": datetime.now().isoformat()
        }
        save_state(state)
        raise

def sleep_step(name, duration_seconds):
    """Durable sleep that survives restarts."""
    state = load_state()
    sleep_key = f"{name}:sleep"

    if sleep_key in state["steps"]:
        step_state = state["steps"][sleep_key]
        if step_state.get("status") == "completed":
            return

        if step_state.get("status") == "sleeping":
            wake_at = datetime.fromisoformat(step_state["wakeAt"])
            now = datetime.now()
            if now >= wake_at:
                state["steps"][sleep_key]["status"] = "completed"
                state["steps"][sleep_key]["completedAt"] = now.isoformat()
                save_state(state)
                return
            # Wait for remaining time
            remaining = (wake_at - now).total_seconds()
            time.sleep(remaining)
            state["steps"][sleep_key]["status"] = "completed"
            state["steps"][sleep_key]["completedAt"] = datetime.now().isoformat()
            save_state(state)
            return

    # Start sleeping
    wake_at = datetime.now().timestamp() + duration_seconds
    state["steps"][sleep_key] = {
        "status": "sleeping",
        "wakeAt": datetime.fromtimestamp(wake_at).isoformat(),
        "startedAt": datetime.now().isoformat()
    }
    save_state(state)

    time.sleep(duration_seconds)

    state["steps"][sleep_key]["status"] = "completed"
    state["steps"][sleep_key]["completedAt"] = datetime.now().isoformat()
    save_state(state)

class WorkflowContext:
    def __init__(self):
        self.step = step
        self.sleep = sleep_step

# User workflow code
%s

def main():
    input_data = json.loads(os.environ.get("INPUT", "{}"))
    ctx = WorkflowContext()

    try:
        output = workflow(input_data, ctx)
        print(json.dumps({"status": "completed", "output": output}))

        if WEBHOOK_URL:
            req = urllib.request.Request(
                WEBHOOK_URL,
                data=json.dumps({"runId": RUN_ID, "status": "completed", "output": output}).encode(),
                headers={"Content-Type": "application/json"},
                method="POST"
            )
            urllib.request.urlopen(req)

    except Exception as e:
        print(json.dumps({"status": "failed", "error": str(e)}))

        if WEBHOOK_URL:
            req = urllib.request.Request(
                WEBHOOK_URL,
                data=json.dumps({"runId": RUN_ID, "status": "failed", "error": str(e)}).encode(),
                headers={"Content-Type": "application/json"},
                method="POST"
            )
            urllib.request.urlopen(req)

        exit(1)

if __name__ == "__main__":
    main()
`, workflow.Name, workflow.Version, workflow.ID, workflow.Code)
}

// Start initiates a new workflow run locally.
func (e *ExecAdapter) Start(ctx context.Context, workflowID string, input map[string]any) (*WorkflowRun, error) {
	// Generate run ID
	runID := fmt.Sprintf("%s-%d", workflowID, time.Now().UnixNano())

	// Create run directory
	runDir := filepath.Join(e.workDir, "runs", runID)
	if err := os.MkdirAll(runDir, 0755); err != nil {
		return nil, fmt.Errorf("create run dir: %w", err)
	}

	// Load workflow
	workflowDir := filepath.Join(e.workDir, "workflows", workflowID)
	metaPath := filepath.Join(workflowDir, "workflow.json")
	metaData, err := os.ReadFile(metaPath)
	if err != nil {
		return nil, fmt.Errorf("read workflow metadata: %w", err)
	}

	var workflow WorkflowDefinition
	if err := json.Unmarshal(metaData, &workflow); err != nil {
		return nil, fmt.Errorf("parse workflow metadata: %w", err)
	}

	// Determine executable
	var codePath string
	var cmd *exec.Cmd

	switch workflow.Runtime {
	case "node", "javascript":
		codePath = filepath.Join(workflowDir, "workflow.js")
		cmd = exec.CommandContext(ctx, "node", codePath)
	case "python":
		codePath = filepath.Join(workflowDir, "workflow.py")
		cmd = exec.CommandContext(ctx, "python3", codePath)
	default:
		codePath = filepath.Join(workflowDir, "workflow.js")
		cmd = exec.CommandContext(ctx, "node", codePath)
	}

	// Set environment
	inputJSON, _ := json.Marshal(input)
	cmd.Env = append(os.Environ(),
		"RUN_ID="+runID,
		"STATE_DIR="+runDir,
		"INPUT="+string(inputJSON),
		"WEBHOOK_URL="+e.webhookURL,
	)

	// Capture output
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	// Create run record
	run := &WorkflowRun{
		ID:         runID,
		WorkflowID: workflowID,
		Status:     StatusRunning,
		Input:      input,
		StartedAt:  time.Now(),
	}

	e.mu.Lock()
	e.runs[runID] = run
	e.processes[runID] = cmd
	e.mu.Unlock()

	// Start async execution
	go func() {
		err := cmd.Run()

		e.mu.Lock()
		defer e.mu.Unlock()

		now := time.Now()
		run.CompletedAt = &now

		if err != nil {
			run.Status = StatusFailed
			run.Error = stderr.String()
			if run.Error == "" {
				run.Error = err.Error()
			}
		} else {
			// Parse output
			var result struct {
				Status string         `json:"status"`
				Output map[string]any `json:"output"`
				Error  string         `json:"error"`
			}
			if err := json.Unmarshal(stdout.Bytes(), &result); err == nil {
				if result.Status == "completed" {
					run.Status = StatusCompleted
					run.Output = result.Output
				} else {
					run.Status = StatusFailed
					run.Error = result.Error
				}
			} else {
				run.Status = StatusCompleted
				run.Output = map[string]any{"raw": stdout.String()}
			}
		}

		// Write final state
		stateData, _ := json.MarshalIndent(run, "", "  ")
		os.WriteFile(filepath.Join(runDir, "result.json"), stateData, 0644)

		delete(e.processes, runID)
	}()

	return run, nil
}

// Status retrieves the current status of a workflow run.
func (e *ExecAdapter) Status(ctx context.Context, runID string) (*WorkflowRun, error) {
	e.mu.RLock()
	defer e.mu.RUnlock()

	run, ok := e.runs[runID]
	if !ok {
		// Try to load from disk
		runDir := filepath.Join(e.workDir, "runs", runID)
		resultPath := filepath.Join(runDir, "result.json")
		data, err := os.ReadFile(resultPath)
		if err != nil {
			return nil, fmt.Errorf("run not found: %s", runID)
		}

		var diskRun WorkflowRun
		if err := json.Unmarshal(data, &diskRun); err != nil {
			return nil, fmt.Errorf("parse run result: %w", err)
		}
		return &diskRun, nil
	}

	return run, nil
}

// Cancel attempts to cancel a running workflow.
func (e *ExecAdapter) Cancel(ctx context.Context, runID string) error {
	e.mu.Lock()
	defer e.mu.Unlock()

	cmd, ok := e.processes[runID]
	if !ok {
		return fmt.Errorf("process not found or already completed")
	}

	if cmd.Process != nil {
		cmd.Process.Kill()
	}

	if run, ok := e.runs[runID]; ok {
		run.Status = StatusCanceled
		now := time.Now()
		run.CompletedAt = &now
	}

	return nil
}

// Logs retrieves execution logs for a workflow run.
func (e *ExecAdapter) Logs(ctx context.Context, runID string) ([]string, error) {
	runDir := filepath.Join(e.workDir, "runs", runID)

	// Check for log files
	var logs []string

	logPath := filepath.Join(runDir, "output.log")
	if data, err := os.ReadFile(logPath); err == nil {
		logs = append(logs, string(data))
	}

	return logs, nil
}

// Cleanup removes completed workflow resources.
func (e *ExecAdapter) Cleanup(ctx context.Context, runID string) error {
	e.mu.Lock()
	delete(e.runs, runID)
	delete(e.processes, runID)
	e.mu.Unlock()

	runDir := filepath.Join(e.workDir, "runs", runID)
	return os.RemoveAll(runDir)
}

// ListRuns returns recent workflow runs.
func (e *ExecAdapter) ListRuns(ctx context.Context, workflowID string, limit int) ([]*WorkflowRun, error) {
	e.mu.RLock()
	defer e.mu.RUnlock()

	var runs []*WorkflowRun
	for _, run := range e.runs {
		if workflowID == "" || run.WorkflowID == workflowID {
			runs = append(runs, run)
			if limit > 0 && len(runs) >= limit {
				break
			}
		}
	}

	return runs, nil
}
